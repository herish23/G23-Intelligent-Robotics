import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import shift
import os
import csv

# --- 1. CONFIGURATION (MUST BE SET BY YOU) ---

# CRITICAL: This MUST match your map file. (e.g., if your map is 20m wide and 400 pixels, resolution is 20/400 = 0.05)
MAP_RESOLUTION_METERS_PER_CELL = 0.05 

# Set the max range of your sensor in METERS (to match CSV data)
MAX_RANGE_METERS = 20.0 

# The CSV file to load
SENSOR_DATA_FILE = 'sensor_data_clean.csv'

# --- 2. MAP & SENSOR LOADING ---

def load_map_from_csv(r'C:\Users\Rohit\Desktop\Intelligent Robotics\G23-Intelligent-Robotics\data\sensor_data_clean.csv):
    """
    Loads a map from a simple CSV file.
    Assumes 1 = WALL, 0 = FREE.
    """
    try:
        grid = np.genfromtxt(filepath, delimiter=',', dtype=float)
        # Ensure 1s are WALL and 0s are FREE
        grid[grid != 0] = 1.0 # Set all non-zero to WALL
        grid = np.nan_to_num(grid, nan=1.0) # Treat empty/bad cells as WALL
        print(f"Successfully loaded map from {filepath} with shape {grid.shape}")
        return grid
    except Exception as e:
        print(f"Error loading map file {filepath}: {e}")
        print("Falling back to default map.")
        return None

def create_map():
    """Creates the default 2D map if no file is loaded."""
    GRID_SIZE = 40
    WALL = 1.0
    FREE = 0.0
    grid = np.zeros((GRID_SIZE, GRID_SIZE), dtype=float)
    grid[0, :] = WALL
    grid[-1, :] = WALL
    grid[:, 0] = WALL
    grid[:, -1] = WALL
    grid[10:30, 15] = WALL
    grid[10:20, 25] = WALL
    grid[30, 20:35] = WALL
    grid[15, 20:30] = WALL
    grid[1:10, 30] = WALL
    print("Using default procedural map.")
    return grid

def load_sensor_data(filepath):
    """Loads the header and all data rows from the sensor CSV."""
    if not os.path.exists(filepath):
        print(f"FATAL ERROR: Sensor file not found at {filepath}")
        return None, None
        
    with open(filepath, 'r') as f:
        reader = csv.reader(f)
        try:
            header = next(reader)
            data = [row for row in reader]
            print(f"Loaded {len(data)} readings from {filepath}")
            return header, data
        except StopIteration:
            print(f"FATAL ERROR: Sensor file {filepath} is empty.")
            return None, None
        except Exception as e:
            print(f"FATAL ERROR: Could not read {filepath}. Error: {e}")
            return None, None

# --- 3. PROBABILITY & GEOMETRY (Your Core Logic) ---

P_HIT = 0.9
P_MISS = 0.01
P_MAX_RANGE = 0.05

def initialize_belief(grid):
    """Initializes the probability distribution (belief) uniformly over free space."""
    belief = np.where(grid == 0.0, 1.0, 0.0) # 0.0 is FREE
    total_free_cells = np.sum(belief)
    if total_free_cells > 0:
        belief /= total_free_cells
    else:
        print("Error: Map has no free space!")
        belief.fill(1.0 / grid.size)
    return belief

def ray_cast_distance(grid, grid_size, max_range_cells, x, y, dx, dy):
    """
    Simulates a ray cast in GRID CELL units.
    """
    fx, fy = float(x), float(y)
    dist = 0.0
    max_steps = int(max_range_cells) * 2

    for _ in range(max_steps):
        fx += dx
        fy += dy
        ix, iy = int(round(fx)), int(round(fy))

        if not (0 <= ix < grid_size and 0 <= iy < grid_size):
            return max_range_cells # Hit map boundary
        if grid[iy, ix] == 1.0: # 1.0 is WALL
            return np.sqrt((ix - x)**2 + (iy - y)**2) # Hit wall

        dist += np.sqrt(dx**2 + dy**2)
        if dist > max_range_cells:
            return max_range_cells
    return max_range_cells

def get_expected_measurement(grid, grid_size, max_range_cells, pos, angle_deg):
    """Calculates the expected range measurement in GRID CELL units."""
    x, y = pos
    angle_rad = np.deg2rad(angle_deg)
    dx = np.cos(angle_rad) * 0.5 # Step size in cells
    dy = np.sin(angle_rad) * 0.5
    return ray_cast_distance(grid, grid_size, max_range_cells, x, y, dx, dy)

def update_prediction(belief, motion_delta, grid):
    """
    Updates the belief state based on the robot's motion (Prediction Step).
    --- THIS IS NOT USED IN THIS SCRIPT, as we have no motion data ---
    """
    dx, dy = motion_delta
    grid_size = grid.shape[0]
    new_belief = shift(belief, (-dy, -dx), mode='wrap', cval=0)

    blurred_belief = np.copy(new_belief)
    for i in range(1, grid_size - 1):
        for j in range(1, grid_size - 1):
            sum_prob = new_belief[i, j] * 0.4
            sum_prob += np.sum(new_belief[i-1:i+2, j-1:j+2]) * 0.0667
            blurred_belief[i, j] = sum_prob

    blurred_belief[grid == 1.0] = 0.0 # 1.0 is WALL

    sum_belief = np.sum(blurred_belief)
    if sum_belief <= 1e-12:
        return initialize_belief(grid)
    return blurred_belief / np.sum(blurred_belief)

def update_correction(belief, grid, grid_size, max_range_cells, measurement_cells, angle_deg):
    """
    Updates the belief state based on a new measurement (Correction Step).
    All logic is in GRID CELL units.
    """
    new_belief = np.zeros_like(belief)
    max_range_check = max_range_cells * 0.95

    for y in range(grid_size):
        for x in range(grid_size):
            if grid[y, x] == 0.0: # 0.0 is FREE
                # 1. Calculate expected measurement in CELLS
                expected_dist_cells = get_expected_measurement(grid, grid_size, max_range_cells, (x, y), angle_deg)

                # 2. Calculate Likelihood P(measurement | pos)
                likelihood = 0.0
                if measurement_cells >= max_range_check:
                    if expected_dist_cells >= max_range_check:
                        likelihood = P_HIT
                    else:
                        likelihood = P_MAX_RANGE
                else:
                    error = abs(measurement_cells - expected_dist_cells)
                    if error < 1.0:
                        likelihood = P_HIT * np.exp(-0.5 * error**2)
                    elif error > 10.0:
                        likelihood = P_MISS
                    else:
                        likelihood = P_MISS + (P_HIT - P_MISS) * np.exp(-0.05 * error)
                
                new_belief[y, x] = likelihood * belief[y, x]

    # 4. Normalize
    sum_belief = np.sum(new_belief)
    if sum_belief > 0:
        return new_belief / sum_belief
    else:
        print(f"Warning: Belief collapsed on angle {angle_deg}. Re-initializing.")
        return initialize_belief(grid)

# --- 4. VISUALIZATION ---

def plot_state(fig, grid, belief, title):
    """Plots the state onto the existing figure object 'fig'."""
    fig.clf() 

    # Subplot 1: Map
    ax1 = fig.add_subplot(1, 2, 1)
    ax1.imshow(grid, cmap='binary', origin='lower')
    ax1.set_title("Environment Map")
    ax1.set_xticks([]), ax1.set_yticks([])

    # Subplot 2: Belief Distribution
    ax2 = fig.add_subplot(1, 2, 2)
    masked_belief = np.ma.masked_where(belief <= 1e-10, belief)
    vmax = np.max(belief) if np.max(belief) > 0 else 1.0
    
    ax2.imshow(grid, cmap='binary', origin='lower') # Show map underneath
    im = ax2.imshow(masked_belief, cmap='viridis', origin='lower', vmin=0, vmax=vmax, alpha=0.8)
    
    ax2.set_title(title)
    ax2.set_xticks([]), ax2.set_yticks([])
    
    fig.colorbar(im, ax=ax2, label='Probability')
    plt.tight_layout()
    plt.pause(0.1) # Pause to allow plot to update

# --- 5. MAIN SIMULATION LOOP ---

def main():
    print("--- Starting Offline Localization (Kidnapped Robot) ---")
    
    # --- A. Load Map ---
    # To use your own map:
    # 1. Create a file 'my_map.csv' (1s for walls, 0s for free space)
    # 2. Uncomment the next line:
    
    # The 'create_map()' function has been removed as requested.
    # You MUST provide 'my_map.csv' for this script to work.
    grid = load_map_from_csv('my_map.csv')
    
    # For now, we use the default map
    # grid = create_map() - This line has been removed.
    
    if grid is None:
        print("FATAL ERROR: Map file 'my_map.csv' not found or failed to load. Exiting.")
        return

    GRID_SIZE = grid.shape[0] # Get size from the loaded map
    # Convert MAX_RANGE from meters to cells
    MAX_RANGE_CELLS = MAX_RANGE_METERS / MAP_RESOLUTION_METERS_PER_CELL
    
    # --- B. Load Sensor Data ---
    header, sensor_data = load_sensor_data(SENSOR_DATA_FILE)
    if header is None:
        return

    # We only need one reading to localize
    first_reading_row = sensor_data[0]
    print(f"Using first sensor reading from timestamp: {first_reading_row[0]}")
    
    # Get all range readings (skip timestamp at index 0)
    ranges_meters = np.array(first_reading_row[1:], dtype=float)
    
    # Clean up data: replace inf, nan, or 0.0 with max range
    ranges_meters[np.isinf(ranges_meters)] = MAX_RANGE_METERS
    ranges_meters[np.isnan(ranges_meters)] = MAX_RANGE_METERS
    ranges_meters[ranges_meters == 0.0] = MAX_RANGE_METERS

    # --- C. Initialize Belief & Plot ---
    plt.ion()
    fig = plt.figure(figsize=(10, 5))
    belief = initialize_belief(grid)
    plot_state(fig, grid, belief, "Initial Uniform Belief")

    # --- D. Run Correction Step for all readings ---
    print("Localizing robot based on single 360-degree scan...")
    
    num_readings = len(ranges_meters)
    angle_step = 360.0 / num_readings
    
    # We can speed this up by sampling the readings
    # (e.g., use every 5th reading)
    for i in range(0, num_readings, 5): 
        measurement_meters = ranges_meters[i]
        angle_deg = i * angle_step
        
        # Convert this one reading from meters to grid cells
        measurement_cells = measurement_meters / MAP_RESOLUTION_METERS_PER_CELL
        
        # Run the correction step
        belief = update_correction(belief, grid, GRID_SIZE, MAX_RANGE_CELLS, measurement_cells, angle_deg)
        
        # Update plot every 20 readings to show progress
        if i % 20 == 0:
            print(f"  ... applying reading {i}/{num_readings} (angle {angle_deg:.0f})")
            plot_state(fig, grid, belief, f"After {i} Sensor Readings")

    # --- E. Show Final Result ---
    print("Localization complete.")
    plot_state(fig, grid, belief, "Final Localized Belief")
    
    est_y, est_x = np.unravel_index(np.argmax(belief), belief.shape)
    confidence = np.max(belief)
    print(f"  > Best Estimate: ({est_x}, {est_y})")
    print(f"  > Confidence: {confidence*100:.2f}%")
    
    plt.ioff()
    plt.show()

if __name__ == "__main__":
    main()